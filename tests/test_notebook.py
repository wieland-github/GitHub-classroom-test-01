# Auto-generated by ChatGPT.
# Tests assume two notebooks are present in repo root:
#   - affectiveSignalVoice.ipynb              (student submission)
#   - affectiveSignalVoice-solutions.ipynb    (instructors-only; not required for students)
#
# If you do not wish to distribute the solutions notebook, keep these tests
# in the private template. The tests will still run structural checks without
# solution behaviors if you also remove the behavior section.

import io
import json
import types
import inspect
import importlib
from pathlib import Path

import nbformat
import pytest

REPO_ROOT = Path(__file__).resolve().parents[1]
NB_STUDENT = REPO_ROOT / "affectiveSignalVoice.ipynb"
NB_SOLUTION = REPO_ROOT / "affectiveSignalVoice-solutions.ipynb"

def _load_notebook_code(path: Path) -> str:
    nb = nbformat.read(path, as_version=4)
    code_cells = [c for c in nb.cells if c.get("cell_type") == "code"]
    chunks = []
    for cell in code_cells:
        src = cell.get("source") or ""
        cleaned = []
        for line in src.splitlines():
            if line.strip().startswith("%") or line.strip().startswith("!"):
                cleaned.append("pass  # stripped-magic")
            else:
                cleaned.append(line)
        chunks.append("\n".join(cleaned))
    return "\n\n".join(chunks)

def _namespace_from_notebook(path: Path) -> dict:
    code = _load_notebook_code(path)
    ns = {}
    exec(compile(code, str(path), "exec"), ns, ns)
    return ns

def _list_public_functions(ns: dict):
    out = {}
    for k, v in ns.items():
        if k.startswith("_"):
            continue
        if isinstance(v, types.FunctionType):
            try:
                sig = inspect.signature(v)
            except Exception:
                continue
            out[k] = sig
    return out

def _iter_testcases(ns: dict, func_name: str):
    """
    The solutions notebook may optionally define a variable named
    TESTCASES_<func_name> that is either:
      - list of tuples (args, kwargs, expected)
      - dict with keys 'args', 'kwargs', 'expected' (or a list of such dicts)
    Return a list of triples (args, kwargs, expected). If nothing found, return [].
    """
    key = f"TESTCASES_{func_name}"
    if key not in ns:
        return []
    data = ns[key]
    cases = []
    if isinstance(data, (list, tuple)):
        for item in data:
            if isinstance(item, (list, tuple)) and len(item) == 3:
                args, kwargs, expected = item
                if not isinstance(kwargs, dict):
                    kwargs = {}
                cases.append((tuple(args) if isinstance(args, (list, tuple)) else (args,), dict(kwargs), expected))
            elif isinstance(item, dict):
                args = item.get("args", [])
                kwargs = item.get("kwargs", {})
                expected = item.get("expected")
                cases.append((tuple(args) if isinstance(args, (list, tuple)) else (args,), dict(kwargs), expected))
    elif isinstance(data, dict):
        args = data.get("args", [])
        kwargs = data.get("kwargs", {})
        expected = data.get("expected")
        cases.append((tuple(args) if isinstance(args, (list, tuple)) else (args,), dict(kwargs), expected))
    return cases

@pytest.fixture(scope="session")
def student_ns():
    assert NB_STUDENT.exists(), f"Student notebook not found at {NB_STUDENT}"
    return _namespace_from_notebook(NB_STUDENT)

@pytest.fixture(scope="session")
def solution_ns():
    if not NB_SOLUTION.exists():
        pytest.skip("Solutions notebook not available; behavior tests will be skipped.")
    return _namespace_from_notebook(NB_SOLUTION)

def test_notebook_executes(student_ns):
    # If we got a namespace, the notebook executed without errors.
    assert isinstance(student_ns, dict)
    # Optional: sanity check that there is at least one function defined.
    funcs = _list_public_functions(student_ns)
    assert len(funcs) >= 1, "No public functions found in the notebook. Did you define any?"

def test_required_functions_present(student_ns, solution_ns):
    # Compare functions defined in solutions vs student
    sol_funcs = _list_public_functions(solution_ns)
    stu_funcs = _list_public_functions(student_ns)
    missing = sorted(set(sol_funcs.keys()) - set(stu_funcs.keys()))
    assert not missing, f"Missing required function(s): {missing}"

def test_function_signatures_match(student_ns, solution_ns):
    sol_funcs = _list_public_functions(solution_ns)
    stu_funcs = _list_public_functions(student_ns)
    mismatched = []
    for name, sol_sig in sol_funcs.items():
        if name not in stu_funcs:
            continue
        stu_sig = stu_funcs[name]
        if str(stu_sig) != str(sol_sig):
            mismatched.append((name, str(sol_sig), str(stu_sig)))
    assert not mismatched, "Signature mismatch(es): " + "; ".join([f"{n}: expected {s}, got {t}" for n, s, t in mismatched])

@pytest.mark.parametrize("func_name", [])
def test_behavior_with_testcases(func_name, student_ns, solution_ns):
    sol_funcs = _list_public_functions(solution_ns)
    stu_funcs = _list_public_functions(student_ns)
    if func_name not in sol_funcs:
        pytest.skip(f"No such function in solutions: {func_name}")
    cases = _iter_testcases(solution_ns, func_name)
    if not cases:
        pytest.skip(f"No TESTCASES_{func_name} provided in solutions; skipping behavior test.")
    sol_func = solution_ns[func_name]
    stu_func = student_ns.get(func_name)
    assert callable(stu_func), f"Function '{func_name}' not implemented."
    for args, kwargs, expected in cases:
        stu_out = stu_func(*args, **kwargs)
        # If expected is callable, compute expected dynamically (useful for tolerance checks)
        if callable(expected):
            exp_val = expected(*args, **kwargs)
        else:
            exp_val = expected
        assert stu_out == exp_val, f"{func_name}({args}, {kwargs}) -> expected {exp_val}, got {stu_out}"
